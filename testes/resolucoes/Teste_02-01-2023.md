
# Teste SD 02/01/2023

## Grupo 01

### Questão 01

- `a` pode ser menor que 0.

### Questão 02

- pesquisa, que recebe um mapa de critérios para valores e devolve uma lista de imóveis encontrados

### Questão 03

- não dispensa a utilização de primitivas de exclusão mútua na lógica da aplicação com estado partilhado do servidor
- dispensa a utilização de primitivas de exclusão mútua na lógica da aplicação no cliente

### Questão 04

- a latência média de entrada na secção crítica é menor do que com um algoritmo em anel
- a latência média de entrada na secção crítica é menor do que com um algoritmo baseado em relógios lógicos (Ricart-Agrawala)

### Questão 05

Num cenário de dados geograficamente distribuídos sujeitos a alterações, a manutenção da consistência é o desafio central. O algoritmo Bully é uma solução clássica para eleger um líder que coordene as escritas, mas a sua aplicação em larga escala na Internet apresenta nuances importantes.

A principal utilidade de eleger um líder neste contexto é estabelecer uma ordem total das operações para garantir a consistência dos dados (evitando conflitos de escrita).
- Coordenação de Escritas: O líder atua como o ponto único de entrada para alterações, enviando as atualizações para as réplicas. Isso simplifica a gestão de concorrência.
- Recuperação Automática: Se o centro de dados que detém o líder falha, o algoritmo Bully permite que os centros de dados restantes detetem a falha e elejam um novo líder sem intervenção humana, mantendo a disponibilidade do sistema.

Apesar de robusto em redes locais, o Bully enfrenta limitações severas em sistemas geograficamente distribuídos através da Internet:
- Ponto Único de Falha e Latência: Embora o Bully ajude a substituir um líder que falhou, o modelo de "líder único" introduz latência elevada para clientes geograficamente distantes do líder.
- Sensibilidade a Partições de Rede: Na Internet, falhas de ligação são comuns. Se o link entre o centro de dados A e B cair, ambos podem eleger o seu próprio líder (cada um pensa que o outro falhou). Isto pode levar a que dois líderes aceitem escritas contraditórias nos mesmos dados, corrompendo a consistência global.
- Overhead de Mensagens em Redes Instáveis: O Bully baseia-se em timeouts. Em ligações de Internet instáveis, falsas deteções de falha podem causar eleições constantes. Como o Bully tem uma complexidade de mensagens de O(n2) no pior caso, um sistema com muitos centros de dados pode ficar paralisado apenas a eleger líderes.

## Grupo 02

### Questão 06

```java
class Cache {
    private static class Entry {
        int key;
        byte[] value;
        Entry(int k, byte[] v) {
            key = k;
            value = v;
        }
    }

    final int N;
    Lock l;
    Condition c;
    Entry[] entries;
    int nextFree;

    Cache(int n) {
        N = n;
        nextFree = -1;
        l = new ReentrantLock();
        c = l.newCondition();
        entries = new Entry[N];
        for (int i = 0; i < N; i++)
            entries[i] = null;
    }

    byte[] get(int key) {
        l.lock();
        try {
            for (int i = 0; i < N; i++)
                if (entries[i] != null && entries[i].key == key)
                    return entries[i].value;
        } finally { l.unlock(); }
    }

    void evict(int key) {
        l.lock();
        try {
            for (int i = 0; i < N; i++)
                if (entries[i] != null && entries[i].key == key) {
                    entries[i] = null;
                    nextFree = i;
                    c.signal();
                    break;
                }
        } finally { l.unlock(); }
    }

    void put(int key, byte[] value) {
        l.lock();
        try {
            int posFree = -1;
            for (int i = 0; i < N; i++) {
                if (entries[i] == null)
                    posFree = i;
                else if (entries[i].key == key) {
                    entries[i].value = value;
                    return;
                }
            }

            if (posFree == -1) {
                while (nextFree == -1)
                    c.await();
                posFree = nextFree;
                nextFree = -1;
            }
            entries[posFree] = new Entry(key, value);
        } finally { l.unlock(); }
    }
}
```

### Questão 07

```java
```
