
# Teste SD 09/12/2024

## Grupo 01

### Questão 01

As arquiteturas definem como os componentes interagem e como a responsabilidade é partilhada:
- **Cliente-Servidor**: É a arquitetura mais comum, onde existe uma distinção clara de papéis. Os servidores oferecem serviços e os clientes consomem-nos. É fácil de gerir centralizadamente, mas o servidor pode tornar-se um ponto único de falha e um gargalo de desempenho.
- **Peer-to-Peer (P2P)**: Todos os nós (peers) têm papéis simétricos, agindo simultaneamente como clientes e servidores. Oferece elevada escalabilidade e resiliência, mas é mais complexa de gerir e pesquisar.
- **Arquitetura em Camadas**: Separa as responsabilidades em níveis. Facilita a manutenção e permite que cada camada escale independentemente.
- **Arquitetura Baseada em Objetos**: Os sistemas são vistos como coleções de objetos que comunicam através de chamadas de métodos remotos, focando-se na transparência de localização.


### Questão 02

Para evitar que a sincronização degrade a performance (devido a contenção e bloqueios), devem seguir-se estes princípios:
- **Reduzir a Granularidade**: Em vez de um único lock para uma estrutura de dados inteira, usar locks para partes menores.
- **Diminuir o Tempo de Posse**: Manter apenas as operações críticas (acesso a memória partilhada) dentro do bloco protegido. Operações demoradas, como I/O ou cálculos complexos que não dependem do recurso partilhado, devem estar fora do lock.
- **Reader-Writer Locks**: Quando há muitas leituras e poucas escritas, permitir que múltiplos leitores acedam simultaneamente ao recurso, bloqueando apenas quando ocorre uma escrita.
- **Evitar Deadlocks**: Estabelecer uma ordem hierárquica estrita para a aquisição de múltiplos locks.


### Questão 03

A serialização é o processo de converter estruturas de dados complexas ou objetos em memória para um formato que possa ser transmitido. **Importância**: É essencial para a comunicação entre nós que podem ter arquiteturas de CPU diferentes (ex: Little-endian vs Big-endian) ou linguagens de programação distintas. Garante que a semântica dos dados seja preservada na rede.

**Obstáculos**:
- Heterogeneidade: Diferentes representações de inteiros, reais e caracteres entre máquinas.
- Ponteiros e Referências: Não se pode enviar um endereço de memória diretamente, pois ele não faz sentido na máquina remota; é necessário "aplanar" as estruturas ligadas.
- Performance: O processo de codificação/descodificação consome CPU e aumenta o tamanho das mensagens (overhead).


### Questão 04

Um relógio lógico captura a relação de Precedência Causal (a -> b).
- Relação Capturada: Se um evento `a` acontece antes de `b` no mesmo processo, ou se `a` é o envio de uma mensagem e `b` a sua receção, então `L(a) < L(b)`. Ele permite ordenar eventos sem depender de relógios físicos sincronizados, garantindo que a causa venha sempre antes do efeito.
- Suficiência para Exclusão Mútua: O relógio lógico sozinho não é suficiente para implementar exclusão mútua distribuída de forma completa, ele é apenas uma ferramenta de ordenação.
- Porquê? A exclusão mútua exige um protocolo adicional que utilize os timestamps dos relógios lógicos para decidir quem tem prioridade na fila de espera, além de mecanismos para garantir a entrega de mensagens e a gestão de falhas de nós.

## Grupo 02


```java
class Manager {
    Lock l = new ReentrantLock();
    Condition c = l.newCondition();
    boolean[] docks = new boolean[28]; // inicializado a false

    Trip permission(int size) {
        l.lock();
        try {
            int start = size * 4;
            while (true) {
                for (int i = 0; i < start; i < 28; i++) {
                    if (docks[i] == false) {
                        docks[i] = true;
                        return new Trip(i, this);
                    }
                }
                c.await();
            }
        } finally { l.unlock(); }
    }

    void depart(int dock) {
        l.lock();
        try {
            docks[dock] = false;
            c.signal();
        } finally { l.unlock(); }
    }
}
```

```java
class Trip {
    final int dock;
    Lock l;
    Condition c;
    Manager manager;
    boolean disembarked;

    Trip(int d, Manager m) {
        dock = d;
        l = new ReentrantLock();
        c = l.newCondition();
        manager = m;
        disembarked = false;
    }

    int dockId() { return dock; }

    void waitDisembark() {
        l.lock();
        try {
            while (!disembarked) c.await();
        } finally { l.unlock(); }
    }

    void finishedDisembarked() {
        l.lock();
        disembarked = true;
        c.signalAll();
        l.unlock();
    }

    void depart() {
        l.lock();
        if (disembarked) manager.depart(dock);
        l.unlock();
    }
}
```

## Grupo 03

```java
```
