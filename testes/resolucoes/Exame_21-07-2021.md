
# Exame SD 21/07/2021

## Grupo 01

### Questão 01

- da eficiência das primitivas de sincronização usadas para exclusão mútua

### Questão 02

- funciona melhor quando os atrasos na rede entre os servidores envolvidos são simétricos (i.e. iguais nos dois sentidos)

### Questão 03

- contribui principalmente para a redução da latência percebida pelo utilizador

### Questão 04

- o coordenador falha antes de enviar a decisão no início da segunda fase

### Questão 05

Num cenário com múltiplos threads a invocar o mesmo servidor concorrentemente através da mesma ligação física, o desafio principal é a identificação e o encaminhamento correto das respostas.
- problema: como as mensagens são enviadas de forma assíncrona ou concorrente, o servidor pode processar pedidos de durações diferentes e enviar as respostas numa ordem diferente daquela em que os pedidos foram feitos.
- consequência: sem um mecanismo de controlo, a Thread A poderia ler do socket uma resposta que, na verdade, pertence ao pedido feito pela Thread B, gerando corrupção de dados ou erros de execução.

A solução típica envolve a implementação de um mecanismo de multiplexagem de pedidos no lado do cliente:
- identificador de transação: o middleware atribui um número de sequência único a cada pedido antes de o enviar para o servidor. Este ID é incluído no cabeçalho da mensagem.
- tabela de chamadas pendentes: no lado do cliente, o middleware mantém uma estrutura de dados que mapeia o ID do pedido para o objeto de sincronização da thread que o originou.
- thread recetora (Dispatcher): existe uma thread específica no cliente dedicada apenas a ler o socket. Quando chega uma resposta:
    - ela extrai o ID da mensagem.
    - procura na Tabela de Chamadas Pendentes.
    - entrega o resultado e acorda a thread específica que estava bloqueada à espera daquela resposta.

## Grupo 02

### Questão 06

```java
```

### Questão 07

```java
```
