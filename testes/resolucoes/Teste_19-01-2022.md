
# Teste SD 19/01/2022

## Grupo 01

### Questão 01

- leva a uma espera ativa que é ineficiente

### Questão 02

- funciona melhor quando o atraso total na rede é em média mais pequeno
- funciona melhor quando os atrasos na rede entre os servidores envolvidos são simétricos (i.e., iguais nos dois sentidos)

### Questão 03

- dispensa a utilização de primitivas de exclusão mútua na lógica da aplicação no cliente
- é compatível com a clientes multi-thread

### Questão 04

- é adequada a um sistema administrativamente descentralizado
- permite obter uma resposta consultando menos nós que um sistema hierárquico de dimensão semelhante

### Questão 05

**Problema**: Gasto Duplo

O desafio fundamental é garantir que todos os nós, distribuídos globalmente, concordem com uma ordem total de transações. Se um utilizador tentar gastar a mesma quantia simultaneamente em dois locais diferentes da rede, o sistema deve garantir que apenas uma dessas transações seja aceite e que todos os participantes atualizem os seus registos de forma idêntica para evitar a inconsistência.

**Solução Típica**: Algoritmo de Consenso Distribuído

Em ambientes abertos e de larga escala como a Internet, a solução típica baseia-se num mecanismo de Consenso, frequentemente implementado através de protocolos de consenso de quórum, como o Paxos.


## Grupo 02

### Questão 06

```java

class Votacao {
    static final int C = 10;
    static final int E = 5;

    Set<Integer> verificados = new HashSet();
    boolean[] cabines = new boolean[C];
    int[] votos = new int[E]; // inicializado a 0
    int count = 0; // contagem de votos
    boolean terminado = false;
    Lock l = new ReentrantLock();
    Condition c = l.newCondition();
    Condition esperaVencedor = l.newCondition();

    boolean verifica(int identidade) {
        l.lock();
        try {
            if (terminado) return false;

            boolean out = verificados.contains(identidade);
            if (!out) {
                verificados.add(identidade);
                return true;
            }
            return false;
        } finally { l.unlock(); }
    }

    int esperaPorCabine() {
        l.lock();
        try {
            while (true) {
                for (int i = 0; i < C; i++) {
                    if (!cabines[i]) {
                        cabines[i] = true;
                        return i + 1;
                    }
                }
                c.await();
            }

        } finally { l.unlock(); }
    }

    void vota(int escolha) {
        l.lock();
        try {
            // voto válido
            if (escolha > 0 && escolha <= E) {
                votos[escolha-1]++;
                count++;
                esperaVencedor.signalAll();
            }
        } finally { l.unlock(); }
    }

    void desocupaCabine(int i) {
        l.lock();
        try {
            cabines[i] = false;
            c.signal();
        } finally { l.unlock(); }
    }

    int vencedor() {
        l.lock();
        try {
            terminado = true;
            while (count < verificados.size())
                esperaVencedor.await();

            int max = 0;
            for (int i = 0; i < E; i++) {
                if (votos[i] > votos[max]) max = i;
            }
            return max;
        } finally { l.unlock(); }
    }
}

```

### Questão 07

```java
```
