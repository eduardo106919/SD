
# Exame SD 27/01/2025


## Grupo 01

### Questão 01

A arquitetura Cliente-Servidor é um modelo de interação que pode ser encontrado dentro das outras arquiteturas da seguinte forma:
- Layered: É o exemplo mais direto. Cada camada atua como um servidor para a camada superior, fornecendo serviços, e como um cliente para a camada inferior, solicitando operações.
- Event-Based: Aqui, o modelo cliente-servidor aparece na relação entre os componentes e o servidor. Um componente atua como cliente ao publicar um evento ou ao subscrever-se para receber notificações que o servidor gere e distribui.
- Peer-to-Peer: Embora seja uma arquitetura descentralizada, o modelo cliente-servidor ocorre ao nível do nó individual. Em qualquer transação peer-to-peer, o nó que solicita um recurso atua temporariamente como cliente, enquanto o nó que fornece esse recurso atua como servidor.


### Questão 02

**Porquê**: Uma variável de condição é usada para esperar por um predicado lógico. Sem um lock, ocorreria uma race condition: a condição poderia mudar entre o momento em que a thread verifica o estado e o momento em que se coloca em espera, levando a bloqueios infinitos.

**Como**: O lock protege a variável de estado. Quando uma thread chama await(), ela liberta o lock atomicamente para permitir que outras mudem o estado. Ao ser acordada, ela reacquire o lock antes de continuar.

```
lock.acquire()
while (fila.vazia()) {
    cond_var.wait(lock)
}
item = fila.remover()
lock.release()
```

### Questão 03

Devemos evitar que uma única thread escreva em múltiplos sockets de clientes diferentes por causa do Bloqueio de I/O:
- Bloqueio em Cadeia: Se o socket de um cliente estiver com o buffer cheio, a operação de write nessa thread irá bloquear.
- Impacto no Desempenho: Se a thread bloquear a escrever para o "Cliente A", ela ficará impedida de servir os "Clientes B, C e D", mesmo que estes tenham redes rápidas. Isto destrói a justiça e o throughput do servidor.

### Questão 04

Num algoritmo baseado em relógios de hardware, é usual assumirmos um limite superior conhecido para o tempo de comunicação.

Porquê?

Incerteza do Tempo: Como os relógios físicos nunca estão perfeitamente sincronizados, precisamos de saber o tempo máximo que uma mensagem demora a chegar para garantir a correção.

Algoritmo de Leases: Se um nó detém um recurso baseado num timestamp de tempo real, ele precisa de garantir que, quando o seu tempo expirar, todos os outros nós também vejam que o tempo expirou. Sem um limite máximo de atraso de rede e um erro máximo de sincronização, não seria possível garantir exclusão mútua sem o risco de dois nós acharem que têm direito ao recurso ao mesmo tempo.


## Grupo 02


## Grupo 03
