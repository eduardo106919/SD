
# Teste SD 04/01/2024

## Grupo 01

### Questão 01

O algoritmo da padaria (Bakery Algorithm) garante que um processo que quer entrar na secção crítica só pode ser ultrapassado no máximo uma vez por cada outro processo graças a duas ideias fundamentais:
- Cada processo escolhe um número (ticket) maior do que todos os existentes. O número escolhido poderá ser repetido, mas é etiquetado com o identificador do processo, para resolver empates. Isto cria uma ordem total e determinística.
- Um processo `Pi` só entra na secção crítica quando não existe nenhum outro processo `Pj` com `(ticket[j], j) < (ticket[i], i)`

Um processo só pode ser ultrapassado por processos que já tinham pedido antes (ticket menor). Processos que chegam depois recebem um ticket maior e não passam à frente. Cada processo entra uma única vez por pedido, logo cada outro processo só o pode ultrapassar uma vez.

**Exemplo**: `p1` tira ticket 3, `p2` tira ticket 1, `p3` tira ticket 2. Ordem de entrada será: `p2 -> p3 -> p1`.

### Questão 02



### Questão 03

A estratégia partilhada por disseminação epidémica (gossip) e pelo Chord DHT é: Escalabilidade por descentralização e limitação de estado

**Disseminação epidémica**
- Cada nó comunica apenas com um pequeno subconjunto aleatório de nós.
- A informação espalha-se como uma epidemia.
- Custo por nó: O(1) por ronda.

**Chord DHT**
- Cada nó mantém apenas O(log N) vizinhos (finger table).
- Localização de chaves em O(log N) mensagens.
- Não existe nó central.

Ambos funcionam eficientemente mesmo com milhões de nós, sem gargalos e tolerantes a falhas


### Questão 04

Em sistemas no mesmo centro de dados podemos usar transações distribuídas com Two-Phase Commit (2PC):
- Prepare: Todos os sistemas (voos, hotéis) confirmam que podem reservar
- Commit: Se todos responderem "sim", a reserva é confirmada, caso contrário, tudo é abortado

Garante atomicidade: ou reserva tudo, ou nada.

## Grupo 02

```java
public class Manager {

    private static class Player {
        String name;
        int minPlayers;
        Raid raid = null;
        Player(String n, int m) {
            name = n;
            minPlayers = m;
        }

    }

    private List<Player> waiting;
    private Lock l;
    private Condition c;
    private final int R;
    private List<Raid> activeRaids;
    private Lock lr;
    private Condition cr;

    Manager(int R) {
        this.R = R;
        this.waiting = new ArrayList<>();
        this.l = new ReentrantLock();
        this.c = l.newCondition();
        this.activeRaids = new ArrayList<>();
        this.lr = new ReentrantLock();
        this.cr = lr.newCondition();
    }

    Raid join(String name, int minPlayers) throws InterruptedException {
        l.lock();
        try {
            Player p = new Player(name, minPlayers);
            waiting.add(p);
            while (p.raid == null) {
                formRaid();
                c.await();
            }
            return p.raid;
        } finally { l.unlock(); }

    }

    void formRaid() {
        int maxMin = 0;
        List<Player> group = new ArrayList<>();
        for (Player wp : waiting) {
            group.add(wp);
            maxMin = Math.max(maxMin, wp.minPlayers);
            if (group.size() >= maxMin) {
                // form raid
                List<String> names = new ArrayList<>();
                for (Player p : group)
                    names.add(p.name);

                Raid raid = new Raid(names, this);
                for (Player p : group)
                    p.raid = raid;

                waiting.removeAll(group);
                c.signalAll();
                return;
            }
        }
    }

    void waitStartRaid(Raid r) throws InterruptedException {
        lr.lock();
        try {
            if (activeRaids.size() < R) {
                r.on = true;
                activeRaids.add(r);
                cr.signalAll();
            } else {
                while (!r.on)
                    cr.await();
            }
        } finally { lr.unlock(); }
    }

    void leaveRaid(Raid r) {
        lr.lock();
        try {
            activeRaids.remove(r);
            cr.signalAll();
        } finally { lr.unlock(); }
    }
}
```

```java
public class Raid {
    int count;
    static Lock l;
    final List<String> names;
    boolean on;
    Manager manager;

    Raid(List<String> ns, Manager m) {
        names = ns;
        count = ns.size();
        on = false;
        l = new ReentrantLock();
        manager = m;
    }

    List<String> players() { return names; }

    void waitStart() throws InterruptedException { manager.waitStartRaid(this); }

    void leave() {
        l.lock();
        try {
            count--;
            if (count == 0) manager.leaveRaid(this);
        } finally { l.unlock(); }
    }
}
```


## Grupo 03

```java
class Server {

    public static void main(String[] args) {
        ServerSocket server = new ServerSocket(12345);
        Manager m = new Manager();
        while (true) {
            Socket client = server.accept();
            Worker w = new Worker(m);
            new Thread(w).start();
        }
    }

    static class Worker implements Runnable {
        Socket s;
        Manager m;
        Raid r;
        Worker (Socket s, Manager m) {
            this.s = s;
            this.m = m;
            this.r = null;
        }

        void run() {
            DataInputStream is = ...;
            DataOutputStream os = ...;
            String comand;
            try {
                while ((comand = is.readUTF()) != null) {
                    switch (comand) {
                        case "join":
                            String name = is.readUTF();
                            in minPlayers = is.readInt();
                            if (r == null) {
                                r = m.join(name, minPlayers);
                                os.writeBoolean(true);
                            } else os.writeBoolean(false);
                            os.flush();
                            break;
                        case "players":
                            if (r == null) os.writeBoolean(false);
                            else {
                                List<String> ps = r.players();
                                os.writeInt(ps.size());
                                for (String s : ps)
                                    os.writeUTF(s);
                            }
                            os.flush();
                            break;
                        case "waitStart":
                            if (r == null) os.writeBoolean(false);
                            else {
                                r.waitStart();
                                os.writeBoolean(true);
                            }
                            os.flush();
                            break;
                        case "leave":
                            if (r == null) os.writeBoolean(false);
                            else {
                                r.leave();
                                r = null;
                                os.writeBoolean(true);
                            }
                            os.flush();
                            break;
                        default:
                            os.writeUTF("pedido inválido");
                            os.flush();
                            break;
                    }
                    is.close();
                    os.close();
                    s.close();
                }
            } catch (Exception ignored) {  }
        }
    }
}
```

