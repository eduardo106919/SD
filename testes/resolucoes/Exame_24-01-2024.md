
# Exame SD 24/01/2024

## Grupo 01

### Questão 01

A afirmação está parcialmente correta, mas o motivo técnico principal não é necessariamente o "bloqueio", mas sim a viabilidade e correção:
- Conceção Original: O algoritmo de Peterson foi desenhado especificamente para dois processos. Ele utiliza variáveis partilhadas que, na sua forma original, não escalam diretamente para N threads sem modificações complexas.
- Espera Ativa: O algoritmo utiliza spin-locks. Em sistemas com muitas threads, isto consome ciclos de CPU inutilmente enquanto as threads esperam pela sua vez, o que degrada severamente a performance.


### Questão 02

A migração de código é uma estratégia comum para melhorar a eficiência de sistemas distribuídos. As principais justificações são:
- Desempenho e Latência: Ao executar o código localmente no cliente, evitam-se múltiplas comunicações de rede para operações simples.
- Escalabilidade: Retira carga de processamento do servidor central e distribui-a pelos milhares de clientes. O servidor deixa de processar a lógica e passa a focar-se apenas na gestão de dados.
- Redução de Largura de Banda: Em vez de enviar grandes volumes de dados brutos para o servidor ser processado, envia-se o "algoritmo" para o cliente, que processa os dados localmente e envia apenas o resultado final.


### Questão 03

O algoritmo de Ricart-Agrawala é um algoritmo distribuído para exclusão mútua que utiliza timestamps de Lamport.
- Vantagem: Ordenação Total e Justiça. O uso de relógios lógicos garante que os pedidos de entrada na secção crítica sejam processados exatamente pela ordem em que "aconteceram". Isto evita o starvation, pois um pedido com um timestamp mais antigo terá sempre prioridade sobre um novo.
- Desvantagem: Ponto Único de Falha Distribuído. Para entrar na secção crítica, um nó precisa da permissão de todos os outros participantes. Se um único nó falhar e não responder, o sistema inteiro bloqueia, pois ninguém consegue obter todas as permissões necessárias.

### Questão 04

O **Problema Principal**: O problema central é o Consenso em Sistemas Distribuídos perante falhas parciais e a necessidade de evitar um Single Point of Failure no componente de gestão. Se o nó que decide onde colocar as VMs falhar, o sistema perde a capacidade de auto-recuperação.

**Proposta de Solução**: Replicação com Algoritmo de Consenso (ex: Paxos).

Justificação:
- Para garantir que o serviço de gestão está sempre disponível, não podemos ter apenas um servidor. Devemos ter um conjunto de réplicas.
- Arquitetura Multi-Master: Em vez de um único servidor, utilizamos um conjunto de réplicas. Para que este serviço seja altamente disponível, precisamos que as réplicas concordem com a ordem das operações (ex: "Colocar VM_A no Host_1").
- Funcionamento do Paxos: O algoritmo Paxos permite que um conjunto de processos chegue a um acordo sobre um único valor, mesmo que alguns processos falhem ou a rede sofra atrasos. Ele opera em fases (Prepare/Promise e Accept/Accepted) para garantir que, uma vez que uma decisão é tomada pela maioria (quorum), ela se torna irrevogável.
- Tolerância a Falhas: Com `2f+1` nós, o sistema consegue tolerar a falha de até f nós. Se o "líder" atual falhar, outro nó pode iniciar uma nova ronda do Paxos para assumir o controlo e garantir que o agendamento das máquinas virtuais continue sem interrupção e sem estados inconsistentes.


## Grupo 02


## Grupo 03


