
# Exame SD 15/07/2023

## Grupo 01

### Questão 01

Do ponto de vista da eficiência, a principal diferença reside na gestão de recursos (memória e CPU) e na escalabilidade:
1-thread-per-connection:
- Eficiência: menos eficiente em sistemas com muitas ligações persistentes (Keep-alive). Uma thread é alocada assim que o cliente se liga e permanece ocupada mesmo que o cliente não esteja a enviar dados (períodos de inatividade).
- Custo: consumo elevado de memória (cada thread tem a sua própria stack) e maior custo de context switching no SO quando o número de ligações é muito alto.

1-thread-per-request:
- Eficiência: muito mais eficiente para lidar com um grande volume de clientes. As threads são retiradas de um Thread Pool apenas quando chega um pedido concreto e voltam para o pool assim que a resposta é enviada.
- Vantagem: permite que um número reduzido de threads sirva um número muito superior de ligações, otimizando o uso da CPU e da memória.

### Questão 02

**Dificuldade Principal**: a presença de ponteiros (referências de memória) e a possibilidade de ciclos ou partilha de objetos. Endereços de memória num computador não têm significado noutro. Além disso, se uma estrutura for circular (ex: uma lista duplamente ligada), um algoritmo ingénuo entraria em recursão infinita.

**Técnica Genérica**: A técnica é a Linearização (ou Marshalling) com base em IDs/Tabelas de Objetos.
- ao serializar, mantém-se um registo (mapa/tabela) de todos os objetos já visitados.
- se um objeto for encontrado pela primeira vez, ele é serializado e recebe um identificador único.
- se for encontrado novamente (referência repetida), em vez de duplicar os dados, grava-se apenas o seu identificador. Na reconstrução (deserialização), o sistema usa essa tabela para restaurar as ligações originais.

### Questão 03

No **Two Phase Commit (2PC)**, a segunda fase é o momento em que o **Coordenador** envia a decisão final (`COMMIT` ou `ABORT`).
Como se resolve: O protocolo baseia-se em Logs de escrita antecipada e na persistência do estado.
- se um participante falha durante a 2ª fase, ao recuperar, ele consulta o seu log local.
- se ele encontrar que estava no estado `PREPARED` (da 1ª fase) mas não tem o desfecho da 2ª fase, ele contacta o **Coordenador** para saber qual foi a decisão.
- como o **Coordenador** mantém a decisão em armazenamento persistente até receber todos os ACKs, ele informará o participante recuperado para efetivar o `COMMIT` ou `ABORT`, garantindo a atomicidade.

### Questão 04

**Problema mais importante**: Consistência e Coordenação (Estado Global Único). Num grupo de servidores, o desafio é garantir que dois clientes não recebam a mesma posição na fila ou que a ordem dos pedidos seja rigorosamente mantida. Sem coordenação, podes ter uma race condition onde dois servidores acham que são os próximos a atender o mesmo cliente.

**Solução Típica**: utilizar um algoritmo de Consenso, como o Paxos. **Explicar Paxos**.


## Grupo 02

### Questão 01

```java
```

### Questão 02

```java
```


